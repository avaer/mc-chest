<!doctype html>
<html>

<head>
  <title>chest</title>
</head>

<body>

<script type=module>
import * as THREE from './three.module.min.js';
import {OrbitControls} from './OrbitControls.js';
import {BufferGeometryUtils} from './BufferGeometryUtils.js';

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  alpha: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 2);

const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
// orbitControls.update();

const _requestImage = src => new Promise((accept, reject) => {
  const img = document.createElement('img');
  img.src = src;
  img.onload = () => {
    accept(img);
  };
  img.onerror = reject;
});

Promise.all([
  _requestImage('./chest-top.png'),
  _requestImage('./chest-front.png'),
  _requestImage('./chest-side.png'),
  _requestImage('./chest-inside.png'),
])
.then(imgs => {
  const canvas = document.createElement('canvas');
  let totalWidth = 0;
  let maxHeight = 0;
  for (const img of imgs) {
    totalWidth += img.width;
    maxHeight = Math.max(img.height, maxHeight);
  }
  canvas.width = totalWidth;
  canvas.height = maxHeight;
  const ctx = canvas.getContext('2d');
  for (let i = 0; i < imgs.length; i++) {
    const img = imgs[i];
    ctx.drawImage(img, i*img.width, 0);
  }

  let index = 0;
  const chestTopUvs = [index/imgs.length, 0, ++index/imgs.length, 1];
  const chestFrontUvs = [index/imgs.length, 0, ++index/imgs.length, 1];
  const chestSideUvs = [index/imgs.length, 0, ++index/imgs.length, 1];
  const chestInsideUvs = [index/imgs.length, 0, ++index/imgs.length, 1];

  const t = new THREE.Texture(canvas);
  t.needsUpdate = true;
  const material = new THREE.MeshBasicMaterial({
    map: t,
  });

  const chestOpenGeometry = (() => {
    const baseGeometry = (() => {
      const geometry = new THREE.BoxBufferGeometry(1, 0.5, 1)
        .applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0.5/2, 0));
      const uvs = geometry.getAttribute('uv').array;
      const numUvs = uvs.length / 2;
      for (let i = 0; i < numUvs; i++) {
        const faceIndex = i >> 2;

        let chestUvs;
        if (faceIndex === 0) { // right
          chestUvs = chestTopUvs;
        } else if (faceIndex === 1) { // left
          chestUvs = chestTopUvs;
        } else if (faceIndex === 2) { // top
          chestUvs = chestInsideUvs;
        } else if (faceIndex === 3) { // bottom
          chestUvs = chestTopUvs;
        } else if (faceIndex === 4) { // front
          chestUvs = chestTopUvs;
        } else {
          chestUvs = chestTopUvs;
        }
        const uvWidth = chestUvs[2] - chestUvs[0];
        const uvHeight = chestUvs[3] - chestUvs[1];
        uvs[i * 2 + 0] = chestUvs[0] + (uvs[i * 2 + 0] * uvWidth);
        uvs[i * 2 + 1] = (chestUvs[1] + uvHeight) - (uvs[i * 2 + 1] * uvHeight);
      }

      return geometry;
    })();
    const lidGeometry = (() => {
      const geometry = new THREE.BoxBufferGeometry(1, 0.2, 1)
        .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(1, 0, 0),
          -Math.PI / 2
        )))
        .applyMatrix4(new THREE.Matrix4().makeTranslation(0, 1, -1/2 - 0.2/2));
      const uvs = geometry.getAttribute('uv').array;
      const numUvs = uvs.length / 2;
      for (let i = 0; i < numUvs; i++) {
        const faceIndex = i >> 2;

        let chestUvs;
        if (faceIndex === 0) { // right
          chestUvs = chestSideUvs;
        } else if (faceIndex === 1) { // left
          chestUvs = chestSideUvs;
        } else if (faceIndex === 2) { // top
          chestUvs = chestTopUvs;
        } else if (faceIndex === 3) { // bottom
          chestUvs = chestInsideUvs;
        } else if (faceIndex === 4) { // front
          chestUvs = chestFrontUvs;
        } else {
          chestUvs = chestSideUvs;
        }
        const uvWidth = chestUvs[2] - chestUvs[0];
        const uvHeight = chestUvs[3] - chestUvs[1];
        uvs[i * 2 + 0] = chestUvs[0] + (uvs[i * 2 + 0] * uvWidth);
        uvs[i * 2 + 1] = (chestUvs[1] + uvHeight) - (uvs[i * 2 + 1] * uvHeight);
      }

      return geometry;
    })();

    const geometry = BufferGeometryUtils.mergeBufferGeometries([
      baseGeometry,
      lidGeometry,
    ]);
    return geometry;
  })();

  const mesh = new THREE.Mesh(chestOpenGeometry, material);
  mesh.frustumCulled = false;
  console.log('for mesh', mesh);
  scene.add(mesh);
});

function animate() {
  orbitControls.update();

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

navigator.xr.addEventListener('sessiongranted', e => {
  let currentSession = null;
  function onSessionStarted(session) {
    session.addEventListener('end', onSessionEnded);

    renderer.xr.setSession(session);

    currentSession = session;
  }
  function onSessionEnded() {
    currentSession.removeEventListener('end', onSessionEnded);

    currentSession = null;
  }
  navigator.xr && navigator.xr.requestSession('immersive-vr', {
    optionalFeatures: [
      'local-floor',
      'bounded-floor',
    ],
  }).then(onSessionStarted);
});

</script>
</body>

</html>
